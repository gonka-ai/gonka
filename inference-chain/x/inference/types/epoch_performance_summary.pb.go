// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: inference/inference/v1/epoch_performance_summary.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EpochPerformanceSummary struct {
	EpochStartHeight      uint64 `protobuf:"varint,1,opt,name=epoch_start_height,json=epochStartHeight,proto3" json:"epoch_start_height,omitempty"`
	ParticipantId         string `protobuf:"bytes,2,opt,name=participant_id,json=participantId,proto3" json:"participant_id,omitempty"`
	InferenceCount        uint64 `protobuf:"varint,3,opt,name=inference_count,json=inferenceCount,proto3" json:"inference_count,omitempty"`
	MissedRequests        uint64 `protobuf:"varint,4,opt,name=missed_requests,json=missedRequests,proto3" json:"missed_requests,omitempty"`
	EarnedCoins           uint64 `protobuf:"varint,5,opt,name=earned_coins,json=earnedCoins,proto3" json:"earned_coins,omitempty"`
	RewardedCoins         uint64 `protobuf:"varint,6,opt,name=rewarded_coins,json=rewardedCoins,proto3" json:"rewarded_coins,omitempty"`
	BurnedCoins           uint64 `protobuf:"varint,7,opt,name=burned_coins,json=burnedCoins,proto3" json:"burned_coins,omitempty"`
	ValidatedInferences   uint64 `protobuf:"varint,8,opt,name=validated_inferences,json=validatedInferences,proto3" json:"validated_inferences,omitempty"`
	InvalidatedInferences uint64 `protobuf:"varint,9,opt,name=invalidated_inferences,json=invalidatedInferences,proto3" json:"invalidated_inferences,omitempty"`
	Claimed               bool   `protobuf:"varint,10,opt,name=claimed,proto3" json:"claimed,omitempty"`
}

func (m *EpochPerformanceSummary) Reset()         { *m = EpochPerformanceSummary{} }
func (m *EpochPerformanceSummary) String() string { return proto.CompactTextString(m) }
func (*EpochPerformanceSummary) ProtoMessage()    {}
func (*EpochPerformanceSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_876ac57d8fa4473d, []int{0}
}
func (m *EpochPerformanceSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochPerformanceSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochPerformanceSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochPerformanceSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochPerformanceSummary.Merge(m, src)
}
func (m *EpochPerformanceSummary) XXX_Size() int {
	return m.Size()
}
func (m *EpochPerformanceSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochPerformanceSummary.DiscardUnknown(m)
}

var xxx_messageInfo_EpochPerformanceSummary proto.InternalMessageInfo

func (m *EpochPerformanceSummary) GetEpochStartHeight() uint64 {
	if m != nil {
		return m.EpochStartHeight
	}
	return 0
}

func (m *EpochPerformanceSummary) GetParticipantId() string {
	if m != nil {
		return m.ParticipantId
	}
	return ""
}

func (m *EpochPerformanceSummary) GetInferenceCount() uint64 {
	if m != nil {
		return m.InferenceCount
	}
	return 0
}

func (m *EpochPerformanceSummary) GetMissedRequests() uint64 {
	if m != nil {
		return m.MissedRequests
	}
	return 0
}

func (m *EpochPerformanceSummary) GetEarnedCoins() uint64 {
	if m != nil {
		return m.EarnedCoins
	}
	return 0
}

func (m *EpochPerformanceSummary) GetRewardedCoins() uint64 {
	if m != nil {
		return m.RewardedCoins
	}
	return 0
}

func (m *EpochPerformanceSummary) GetBurnedCoins() uint64 {
	if m != nil {
		return m.BurnedCoins
	}
	return 0
}

func (m *EpochPerformanceSummary) GetValidatedInferences() uint64 {
	if m != nil {
		return m.ValidatedInferences
	}
	return 0
}

func (m *EpochPerformanceSummary) GetInvalidatedInferences() uint64 {
	if m != nil {
		return m.InvalidatedInferences
	}
	return 0
}

func (m *EpochPerformanceSummary) GetClaimed() bool {
	if m != nil {
		return m.Claimed
	}
	return false
}

func init() {
	proto.RegisterType((*EpochPerformanceSummary)(nil), "inference.inference.EpochPerformanceSummary")
}

func init() {
	proto.RegisterFile("inference/inference/v1/epoch_performance_summary.proto", fileDescriptor_876ac57d8fa4473d)
}

var fileDescriptor_876ac57d8fa4473d = []byte{
	// 369 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0xcd, 0xce, 0x12, 0x31,
	0x14, 0x86, 0x19, 0x3f, 0xe4, 0xa7, 0x02, 0x9a, 0xc1, 0x9f, 0xae, 0x26, 0x60, 0x62, 0x64, 0x61,
	0x20, 0xc4, 0xe0, 0x05, 0x48, 0x4c, 0x64, 0xa5, 0x19, 0x76, 0x6e, 0x9a, 0xd2, 0x1e, 0x98, 0x26,
	0x4c, 0x3b, 0xb6, 0x1d, 0x94, 0xbb, 0xf0, 0x56, 0xbc, 0x0b, 0x97, 0x2c, 0x5d, 0x1a, 0xb8, 0x11,
	0x33, 0xad, 0x94, 0x89, 0xf9, 0x76, 0x67, 0x9e, 0xf7, 0x79, 0xcf, 0x74, 0x71, 0xd0, 0x3b, 0x21,
	0xb7, 0xa0, 0x41, 0x32, 0x98, 0xdd, 0xa6, 0xc3, 0x7c, 0x06, 0x85, 0x62, 0x19, 0x29, 0x40, 0x6f,
	0x95, 0xce, 0xa9, 0x64, 0x40, 0x4c, 0x99, 0xe7, 0x54, 0x1f, 0xa7, 0x85, 0x56, 0x56, 0xc5, 0xc3,
	0x60, 0x4f, 0xc3, 0xf4, 0xf2, 0xe7, 0x1d, 0x7a, 0xf1, 0xa1, 0x2a, 0x7e, 0xbe, 0xf5, 0xd6, 0xbe,
	0x16, 0xbf, 0x41, 0xb1, 0xdf, 0x69, 0x2c, 0xd5, 0x96, 0x64, 0x20, 0x76, 0x99, 0xc5, 0xd1, 0x28,
	0x9a, 0x34, 0xd3, 0x27, 0x2e, 0x59, 0x57, 0xc1, 0x47, 0xc7, 0xe3, 0x57, 0x68, 0x50, 0x50, 0x6d,
	0x05, 0x13, 0x05, 0x95, 0x96, 0x08, 0x8e, 0x1f, 0x8c, 0xa2, 0x49, 0x37, 0xed, 0xd7, 0xe8, 0x8a,
	0xc7, 0xaf, 0xd1, 0xe3, 0xf0, 0x77, 0xc2, 0x54, 0x29, 0x2d, 0xbe, 0x73, 0x1b, 0x07, 0x01, 0x2f,
	0x2b, 0x5a, 0x89, 0xb9, 0x30, 0x06, 0x38, 0xd1, 0xf0, 0xb5, 0x04, 0x63, 0x0d, 0x6e, 0x7a, 0xd1,
	0xe3, 0xf4, 0x1f, 0x8d, 0xc7, 0xa8, 0x07, 0x54, 0x4b, 0xe0, 0x84, 0x29, 0x21, 0x0d, 0x7e, 0xe8,
	0xac, 0x47, 0x9e, 0x2d, 0x2b, 0x54, 0xbd, 0x4d, 0xc3, 0x37, 0xaa, 0x79, 0x90, 0x5a, 0x4e, 0xea,
	0x5f, 0xa9, 0xd7, 0xc6, 0xa8, 0xb7, 0x29, 0x6b, 0x9b, 0xda, 0x7e, 0x93, 0x67, 0x5e, 0x99, 0xa3,
	0xa7, 0x07, 0xba, 0x17, 0x9c, 0x5a, 0xe0, 0x24, 0xbc, 0xd8, 0xe0, 0x8e, 0x53, 0x87, 0x21, 0x5b,
	0x85, 0x28, 0x5e, 0xa0, 0xe7, 0x42, 0xde, 0x5b, 0xea, 0xba, 0xd2, 0xb3, 0x5a, 0x5a, 0xab, 0x61,
	0xd4, 0x66, 0x7b, 0x2a, 0x72, 0xe0, 0x18, 0x8d, 0xa2, 0x49, 0x27, 0xbd, 0x7e, 0xbe, 0xff, 0xf4,
	0xeb, 0x9c, 0x44, 0xa7, 0x73, 0x12, 0xfd, 0x39, 0x27, 0xd1, 0x8f, 0x4b, 0xd2, 0x38, 0x5d, 0x92,
	0xc6, 0xef, 0x4b, 0xd2, 0xf8, 0xb2, 0xd8, 0x09, 0x9b, 0x95, 0x9b, 0x29, 0x53, 0xf9, 0xac, 0xd0,
	0x8a, 0x97, 0xcc, 0x1a, 0x26, 0xfe, 0x3b, 0x95, 0xef, 0xb5, 0xd9, 0x1e, 0x0b, 0x30, 0x9b, 0x96,
	0x3b, 0x90, 0xb7, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x56, 0xd8, 0xe2, 0xd3, 0x5a, 0x02, 0x00,
	0x00,
}

func (m *EpochPerformanceSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochPerformanceSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochPerformanceSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Claimed {
		i--
		if m.Claimed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.InvalidatedInferences != 0 {
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(m.InvalidatedInferences))
		i--
		dAtA[i] = 0x48
	}
	if m.ValidatedInferences != 0 {
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(m.ValidatedInferences))
		i--
		dAtA[i] = 0x40
	}
	if m.BurnedCoins != 0 {
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(m.BurnedCoins))
		i--
		dAtA[i] = 0x38
	}
	if m.RewardedCoins != 0 {
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(m.RewardedCoins))
		i--
		dAtA[i] = 0x30
	}
	if m.EarnedCoins != 0 {
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(m.EarnedCoins))
		i--
		dAtA[i] = 0x28
	}
	if m.MissedRequests != 0 {
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(m.MissedRequests))
		i--
		dAtA[i] = 0x20
	}
	if m.InferenceCount != 0 {
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(m.InferenceCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ParticipantId) > 0 {
		i -= len(m.ParticipantId)
		copy(dAtA[i:], m.ParticipantId)
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(len(m.ParticipantId)))
		i--
		dAtA[i] = 0x12
	}
	if m.EpochStartHeight != 0 {
		i = encodeVarintEpochPerformanceSummary(dAtA, i, uint64(m.EpochStartHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEpochPerformanceSummary(dAtA []byte, offset int, v uint64) int {
	offset -= sovEpochPerformanceSummary(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EpochPerformanceSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochStartHeight != 0 {
		n += 1 + sovEpochPerformanceSummary(uint64(m.EpochStartHeight))
	}
	l = len(m.ParticipantId)
	if l > 0 {
		n += 1 + l + sovEpochPerformanceSummary(uint64(l))
	}
	if m.InferenceCount != 0 {
		n += 1 + sovEpochPerformanceSummary(uint64(m.InferenceCount))
	}
	if m.MissedRequests != 0 {
		n += 1 + sovEpochPerformanceSummary(uint64(m.MissedRequests))
	}
	if m.EarnedCoins != 0 {
		n += 1 + sovEpochPerformanceSummary(uint64(m.EarnedCoins))
	}
	if m.RewardedCoins != 0 {
		n += 1 + sovEpochPerformanceSummary(uint64(m.RewardedCoins))
	}
	if m.BurnedCoins != 0 {
		n += 1 + sovEpochPerformanceSummary(uint64(m.BurnedCoins))
	}
	if m.ValidatedInferences != 0 {
		n += 1 + sovEpochPerformanceSummary(uint64(m.ValidatedInferences))
	}
	if m.InvalidatedInferences != 0 {
		n += 1 + sovEpochPerformanceSummary(uint64(m.InvalidatedInferences))
	}
	if m.Claimed {
		n += 2
	}
	return n
}

func sovEpochPerformanceSummary(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEpochPerformanceSummary(x uint64) (n int) {
	return sovEpochPerformanceSummary(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EpochPerformanceSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpochPerformanceSummary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochPerformanceSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochPerformanceSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochStartHeight", wireType)
			}
			m.EpochStartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochStartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEpochPerformanceSummary
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEpochPerformanceSummary
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferenceCount", wireType)
			}
			m.InferenceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InferenceCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissedRequests", wireType)
			}
			m.MissedRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissedRequests |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarnedCoins", wireType)
			}
			m.EarnedCoins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EarnedCoins |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardedCoins", wireType)
			}
			m.RewardedCoins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardedCoins |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnedCoins", wireType)
			}
			m.BurnedCoins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurnedCoins |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatedInferences", wireType)
			}
			m.ValidatedInferences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatedInferences |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidatedInferences", wireType)
			}
			m.InvalidatedInferences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidatedInferences |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Claimed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEpochPerformanceSummary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEpochPerformanceSummary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEpochPerformanceSummary(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEpochPerformanceSummary
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpochPerformanceSummary
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEpochPerformanceSummary
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEpochPerformanceSummary
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEpochPerformanceSummary
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEpochPerformanceSummary        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEpochPerformanceSummary          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEpochPerformanceSummary = fmt.Errorf("proto: unexpected end of group")
)
