// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: inference/bls/types.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DKGPhase defines the different phases of the Distributed Key Generation process
type DKGPhase int32

const (
	// UNDEFINED represents an uninitialized or unknown phase
	DKGPhase_DKG_PHASE_UNDEFINED DKGPhase = 0
	// DEALING represents the phase where participants submit their dealing parts
	DKGPhase_DKG_PHASE_DEALING DKGPhase = 1
	// VERIFYING represents the phase where participants verify dealing parts
	DKGPhase_DKG_PHASE_VERIFYING DKGPhase = 2
	// COMPLETED represents the phase where DKG has successfully completed
	DKGPhase_DKG_PHASE_COMPLETED DKGPhase = 3
	// FAILED represents the phase where DKG has failed
	DKGPhase_DKG_PHASE_FAILED DKGPhase = 4
	// SIGNED represents the phase where DKG has completed and been validated by previous epoch
	DKGPhase_DKG_PHASE_SIGNED DKGPhase = 5
)

var DKGPhase_name = map[int32]string{
	0: "DKG_PHASE_UNDEFINED",
	1: "DKG_PHASE_DEALING",
	2: "DKG_PHASE_VERIFYING",
	3: "DKG_PHASE_COMPLETED",
	4: "DKG_PHASE_FAILED",
	5: "DKG_PHASE_SIGNED",
}

var DKGPhase_value = map[string]int32{
	"DKG_PHASE_UNDEFINED": 0,
	"DKG_PHASE_DEALING":   1,
	"DKG_PHASE_VERIFYING": 2,
	"DKG_PHASE_COMPLETED": 3,
	"DKG_PHASE_FAILED":    4,
	"DKG_PHASE_SIGNED":    5,
}

func (x DKGPhase) String() string {
	return proto.EnumName(DKGPhase_name, int32(x))
}

func (DKGPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9bacf092f2134906, []int{0}
}

// BLSParticipantInfo contains information about a participant in the DKG process
type BLSParticipantInfo struct {
	// address is the participant's address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// percentage_weight is the participant's weight in the validation set (as string for sdk.Dec compatibility)
	PercentageWeight cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=percentage_weight,json=percentageWeight,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"percentage_weight"`
	// secp256k1_public_key is the participant's secp256k1 public key for encryption
	Secp256K1PublicKey []byte `protobuf:"bytes,3,opt,name=secp256k1_public_key,json=secp256k1PublicKey,proto3" json:"secp256k1_public_key,omitempty"`
	// slot_start_index is the first slot index assigned to this participant
	SlotStartIndex uint32 `protobuf:"varint,4,opt,name=slot_start_index,json=slotStartIndex,proto3" json:"slot_start_index,omitempty"`
	// slot_end_index is the last slot index assigned to this participant (inclusive)
	SlotEndIndex uint32 `protobuf:"varint,5,opt,name=slot_end_index,json=slotEndIndex,proto3" json:"slot_end_index,omitempty"`
}

func (m *BLSParticipantInfo) Reset()         { *m = BLSParticipantInfo{} }
func (m *BLSParticipantInfo) String() string { return proto.CompactTextString(m) }
func (*BLSParticipantInfo) ProtoMessage()    {}
func (*BLSParticipantInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bacf092f2134906, []int{0}
}
func (m *BLSParticipantInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BLSParticipantInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BLSParticipantInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BLSParticipantInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BLSParticipantInfo.Merge(m, src)
}
func (m *BLSParticipantInfo) XXX_Size() int {
	return m.Size()
}
func (m *BLSParticipantInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BLSParticipantInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BLSParticipantInfo proto.InternalMessageInfo

func (m *BLSParticipantInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *BLSParticipantInfo) GetSecp256K1PublicKey() []byte {
	if m != nil {
		return m.Secp256K1PublicKey
	}
	return nil
}

func (m *BLSParticipantInfo) GetSlotStartIndex() uint32 {
	if m != nil {
		return m.SlotStartIndex
	}
	return 0
}

func (m *BLSParticipantInfo) GetSlotEndIndex() uint32 {
	if m != nil {
		return m.SlotEndIndex
	}
	return 0
}

// EncryptedSharesForParticipant contains encrypted shares for a specific participant
type EncryptedSharesForParticipant struct {
	// encrypted_shares contains shares for participant's slot range in order
	// Index i = share for slot (participant.slot_start_index + i)
	EncryptedShares [][]byte `protobuf:"bytes,1,rep,name=encrypted_shares,json=encryptedShares,proto3" json:"encrypted_shares,omitempty"`
}

func (m *EncryptedSharesForParticipant) Reset()         { *m = EncryptedSharesForParticipant{} }
func (m *EncryptedSharesForParticipant) String() string { return proto.CompactTextString(m) }
func (*EncryptedSharesForParticipant) ProtoMessage()    {}
func (*EncryptedSharesForParticipant) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bacf092f2134906, []int{1}
}
func (m *EncryptedSharesForParticipant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptedSharesForParticipant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptedSharesForParticipant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptedSharesForParticipant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedSharesForParticipant.Merge(m, src)
}
func (m *EncryptedSharesForParticipant) XXX_Size() int {
	return m.Size()
}
func (m *EncryptedSharesForParticipant) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedSharesForParticipant.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedSharesForParticipant proto.InternalMessageInfo

func (m *EncryptedSharesForParticipant) GetEncryptedShares() [][]byte {
	if m != nil {
		return m.EncryptedShares
	}
	return nil
}

// DealerPartStorage contains the storage format for a dealer's contribution to DKG
type DealerPartStorage struct {
	// dealer_address is the address of the dealer who submitted this part
	DealerAddress string `protobuf:"bytes,1,opt,name=dealer_address,json=dealerAddress,proto3" json:"dealer_address,omitempty"`
	// commitments are the G2 points C_kj = g * a_kj representing polynomial commitments
	Commitments [][]byte `protobuf:"bytes,2,rep,name=commitments,proto3" json:"commitments,omitempty"`
	// participant_shares contains encrypted shares for all participants in order
	// Index i = shares for EpochBLSData.participants[i]
	ParticipantShares []*EncryptedSharesForParticipant `protobuf:"bytes,3,rep,name=participant_shares,json=participantShares,proto3" json:"participant_shares,omitempty"`
}

func (m *DealerPartStorage) Reset()         { *m = DealerPartStorage{} }
func (m *DealerPartStorage) String() string { return proto.CompactTextString(m) }
func (*DealerPartStorage) ProtoMessage()    {}
func (*DealerPartStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bacf092f2134906, []int{2}
}
func (m *DealerPartStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DealerPartStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DealerPartStorage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DealerPartStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DealerPartStorage.Merge(m, src)
}
func (m *DealerPartStorage) XXX_Size() int {
	return m.Size()
}
func (m *DealerPartStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_DealerPartStorage.DiscardUnknown(m)
}

var xxx_messageInfo_DealerPartStorage proto.InternalMessageInfo

func (m *DealerPartStorage) GetDealerAddress() string {
	if m != nil {
		return m.DealerAddress
	}
	return ""
}

func (m *DealerPartStorage) GetCommitments() [][]byte {
	if m != nil {
		return m.Commitments
	}
	return nil
}

func (m *DealerPartStorage) GetParticipantShares() []*EncryptedSharesForParticipant {
	if m != nil {
		return m.ParticipantShares
	}
	return nil
}

// VerificationVectorSubmission contains verification results from a specific participant
type VerificationVectorSubmission struct {
	// dealer_validity bitmap indicating which dealers this participant verified as valid
	// Index i corresponds to EpochBLSData.participants[i] as dealer
	// true = dealer's shares verified correctly; false = failed verification or no submission
	// Empty array indicates participant has not submitted verification yet
	DealerValidity []bool `protobuf:"varint,1,rep,packed,name=dealer_validity,json=dealerValidity,proto3" json:"dealer_validity,omitempty"`
}

func (m *VerificationVectorSubmission) Reset()         { *m = VerificationVectorSubmission{} }
func (m *VerificationVectorSubmission) String() string { return proto.CompactTextString(m) }
func (*VerificationVectorSubmission) ProtoMessage()    {}
func (*VerificationVectorSubmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bacf092f2134906, []int{3}
}
func (m *VerificationVectorSubmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerificationVectorSubmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerificationVectorSubmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerificationVectorSubmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerificationVectorSubmission.Merge(m, src)
}
func (m *VerificationVectorSubmission) XXX_Size() int {
	return m.Size()
}
func (m *VerificationVectorSubmission) XXX_DiscardUnknown() {
	xxx_messageInfo_VerificationVectorSubmission.DiscardUnknown(m)
}

var xxx_messageInfo_VerificationVectorSubmission proto.InternalMessageInfo

func (m *VerificationVectorSubmission) GetDealerValidity() []bool {
	if m != nil {
		return m.DealerValidity
	}
	return nil
}

// EpochBLSData contains all information about a DKG round for a specific epoch
type EpochBLSData struct {
	// epoch_id uniquely identifies this DKG round
	EpochId uint64 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// i_total_slots is the total number of slots in the DKG
	ITotalSlots uint32 `protobuf:"varint,2,opt,name=i_total_slots,json=iTotalSlots,proto3" json:"i_total_slots,omitempty"`
	// t_slots_degree is the polynomial degree t for the threshold scheme
	TSlotsDegree uint32 `protobuf:"varint,3,opt,name=t_slots_degree,json=tSlotsDegree,proto3" json:"t_slots_degree,omitempty"`
	// participants contains information about all participants in this DKG round
	Participants []BLSParticipantInfo `protobuf:"bytes,4,rep,name=participants,proto3" json:"participants"`
	// dkg_phase indicates the current phase of the DKG process
	DkgPhase DKGPhase `protobuf:"varint,5,opt,name=dkg_phase,json=dkgPhase,proto3,enum=inference.bls.DKGPhase" json:"dkg_phase,omitempty"`
	// dealing_phase_deadline_block is the block height deadline for the dealing phase
	DealingPhaseDeadlineBlock int64 `protobuf:"varint,6,opt,name=dealing_phase_deadline_block,json=dealingPhaseDeadlineBlock,proto3" json:"dealing_phase_deadline_block,omitempty"`
	// verifying_phase_deadline_block is the block height deadline for the verification phase
	VerifyingPhaseDeadlineBlock int64 `protobuf:"varint,7,opt,name=verifying_phase_deadline_block,json=verifyingPhaseDeadlineBlock,proto3" json:"verifying_phase_deadline_block,omitempty"`
	// group_public_key is the final group public key (G2 point) when DKG completes
	GroupPublicKey []byte `protobuf:"bytes,8,opt,name=group_public_key,json=groupPublicKey,proto3" json:"group_public_key,omitempty"`
	// dealer_parts contains dealer contributions in the same order as participants array
	// dealer_parts[i] corresponds to participants[i]'s dealer contribution
	// nil/empty entries indicate that participant has not submitted their dealer part yet
	DealerParts []*DealerPartStorage `protobuf:"bytes,9,rep,name=dealer_parts,json=dealerParts,proto3" json:"dealer_parts,omitempty"`
	// verification_submissions contains verification results from each participant
	// Each entry tracks which dealers that participant verified as valid
	VerificationSubmissions []*VerificationVectorSubmission `protobuf:"bytes,10,rep,name=verification_submissions,json=verificationSubmissions,proto3" json:"verification_submissions,omitempty"`
	// valid_dealers contains the validity of each dealer that was determined during DKG completion
	// This is populated when the DKG transitions to COMPLETED phase
	// Index i corresponds to whether dealer i (participants[i]) is valid
	ValidDealers []bool `protobuf:"varint,11,rep,packed,name=valid_dealers,json=validDealers,proto3" json:"valid_dealers,omitempty"`
	// validation_signature is the final aggregated signature validating this epoch's group public key
	// This signature is created by the previous epoch's validators using their BLS slot shares
	// For Epoch 1 (genesis), this field remains empty (no previous epoch to validate)
	// For Epoch N+1, stores the signature from Epoch N validators confirming the new group public key
	// Format: 48-byte G1 compressed signature
	ValidationSignature []byte `protobuf:"bytes,12,opt,name=validation_signature,json=validationSignature,proto3" json:"validation_signature,omitempty"`
}

func (m *EpochBLSData) Reset()         { *m = EpochBLSData{} }
func (m *EpochBLSData) String() string { return proto.CompactTextString(m) }
func (*EpochBLSData) ProtoMessage()    {}
func (*EpochBLSData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bacf092f2134906, []int{4}
}
func (m *EpochBLSData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochBLSData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochBLSData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochBLSData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochBLSData.Merge(m, src)
}
func (m *EpochBLSData) XXX_Size() int {
	return m.Size()
}
func (m *EpochBLSData) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochBLSData.DiscardUnknown(m)
}

var xxx_messageInfo_EpochBLSData proto.InternalMessageInfo

func (m *EpochBLSData) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *EpochBLSData) GetITotalSlots() uint32 {
	if m != nil {
		return m.ITotalSlots
	}
	return 0
}

func (m *EpochBLSData) GetTSlotsDegree() uint32 {
	if m != nil {
		return m.TSlotsDegree
	}
	return 0
}

func (m *EpochBLSData) GetParticipants() []BLSParticipantInfo {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *EpochBLSData) GetDkgPhase() DKGPhase {
	if m != nil {
		return m.DkgPhase
	}
	return DKGPhase_DKG_PHASE_UNDEFINED
}

func (m *EpochBLSData) GetDealingPhaseDeadlineBlock() int64 {
	if m != nil {
		return m.DealingPhaseDeadlineBlock
	}
	return 0
}

func (m *EpochBLSData) GetVerifyingPhaseDeadlineBlock() int64 {
	if m != nil {
		return m.VerifyingPhaseDeadlineBlock
	}
	return 0
}

func (m *EpochBLSData) GetGroupPublicKey() []byte {
	if m != nil {
		return m.GroupPublicKey
	}
	return nil
}

func (m *EpochBLSData) GetDealerParts() []*DealerPartStorage {
	if m != nil {
		return m.DealerParts
	}
	return nil
}

func (m *EpochBLSData) GetVerificationSubmissions() []*VerificationVectorSubmission {
	if m != nil {
		return m.VerificationSubmissions
	}
	return nil
}

func (m *EpochBLSData) GetValidDealers() []bool {
	if m != nil {
		return m.ValidDealers
	}
	return nil
}

func (m *EpochBLSData) GetValidationSignature() []byte {
	if m != nil {
		return m.ValidationSignature
	}
	return nil
}

func init() {
	proto.RegisterEnum("inference.bls.DKGPhase", DKGPhase_name, DKGPhase_value)
	proto.RegisterType((*BLSParticipantInfo)(nil), "inference.bls.BLSParticipantInfo")
	proto.RegisterType((*EncryptedSharesForParticipant)(nil), "inference.bls.EncryptedSharesForParticipant")
	proto.RegisterType((*DealerPartStorage)(nil), "inference.bls.DealerPartStorage")
	proto.RegisterType((*VerificationVectorSubmission)(nil), "inference.bls.VerificationVectorSubmission")
	proto.RegisterType((*EpochBLSData)(nil), "inference.bls.EpochBLSData")
}

func init() { proto.RegisterFile("inference/bls/types.proto", fileDescriptor_9bacf092f2134906) }

var fileDescriptor_9bacf092f2134906 = []byte{
	// 895 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xdd, 0x6e, 0x22, 0x37,
	0x14, 0x66, 0x02, 0xd9, 0x10, 0x03, 0x59, 0xf0, 0xa6, 0xca, 0x64, 0x77, 0xcb, 0x52, 0xda, 0xaa,
	0xf4, 0x0f, 0x9a, 0xf4, 0xe7, 0xb6, 0x0a, 0x99, 0x09, 0xa5, 0xa1, 0x29, 0x9a, 0xd9, 0xa6, 0x6a,
	0x2b, 0xd5, 0x32, 0xb6, 0x33, 0x58, 0xc0, 0x78, 0x34, 0x36, 0xe9, 0xf2, 0x16, 0x7b, 0xd9, 0x77,
	0xe8, 0x6d, 0x6f, 0xfa, 0x06, 0x7b, 0xb9, 0xea, 0x55, 0xd5, 0x8b, 0x55, 0x95, 0xbc, 0x48, 0x65,
	0x33, 0x30, 0x40, 0xbb, 0xb9, 0x41, 0x73, 0xbe, 0xef, 0xf3, 0xf1, 0x39, 0xc7, 0x9f, 0x31, 0x38,
	0xe4, 0xe1, 0x15, 0x8b, 0x59, 0x48, 0x58, 0x6b, 0x30, 0x96, 0x2d, 0x35, 0x8b, 0x98, 0x6c, 0x46,
	0xb1, 0x50, 0x02, 0x96, 0x96, 0x54, 0x73, 0x30, 0x96, 0x0f, 0x2b, 0x78, 0xc2, 0x43, 0xd1, 0x32,
	0xbf, 0x73, 0xc5, 0xc3, 0x43, 0x22, 0xe4, 0x44, 0x48, 0x64, 0xa2, 0xd6, 0x3c, 0x48, 0xa8, 0xfd,
	0x40, 0x04, 0x62, 0x8e, 0xeb, 0xaf, 0x39, 0x5a, 0x7f, 0xbe, 0x05, 0x60, 0xbb, 0xe7, 0xf7, 0x71,
	0xac, 0x38, 0xe1, 0x11, 0x0e, 0x55, 0x37, 0xbc, 0x12, 0xd0, 0x06, 0x3b, 0x98, 0xd2, 0x98, 0x49,
	0x69, 0x5b, 0x35, 0xab, 0xb1, 0xeb, 0x2d, 0x42, 0xf8, 0x33, 0xa8, 0x44, 0x2c, 0x26, 0x2c, 0x54,
	0x38, 0x60, 0xe8, 0x17, 0xc6, 0x83, 0xa1, 0xb2, 0xb7, 0xb4, 0xa6, 0x7d, 0xf4, 0xe2, 0xd5, 0x93,
	0xcc, 0xdf, 0xaf, 0x9e, 0x3c, 0x9a, 0xef, 0x2b, 0xe9, 0xa8, 0xc9, 0x45, 0x6b, 0x82, 0xd5, 0xb0,
	0xd9, 0x63, 0x01, 0x26, 0x33, 0x87, 0x91, 0x3f, 0x7f, 0xff, 0x18, 0x24, 0x65, 0x39, 0x8c, 0x78,
	0xe5, 0x34, 0xd7, 0xf7, 0x26, 0x15, 0xfc, 0x04, 0xec, 0x4b, 0x46, 0xa2, 0xe3, 0xcf, 0xbf, 0x18,
	0x1d, 0xa1, 0x68, 0x3a, 0x18, 0x73, 0x82, 0x46, 0x6c, 0x66, 0x67, 0x6b, 0x56, 0xa3, 0xe8, 0xc1,
	0x25, 0xd7, 0x37, 0xd4, 0x39, 0x9b, 0xc1, 0x06, 0x28, 0xcb, 0xb1, 0x50, 0x48, 0x2a, 0x1c, 0x2b,
	0xc4, 0x43, 0xca, 0x9e, 0xd9, 0xb9, 0x9a, 0xd5, 0x28, 0x79, 0x7b, 0x1a, 0xf7, 0x35, 0xdc, 0xd5,
	0x28, 0x7c, 0x07, 0x18, 0x04, 0xb1, 0x90, 0x26, 0xba, 0x6d, 0xa3, 0x2b, 0x6a, 0xd4, 0x0d, 0xa9,
	0x51, 0xd5, 0xbf, 0x06, 0x6f, 0xba, 0x21, 0x89, 0x67, 0x91, 0x62, 0xd4, 0x1f, 0xe2, 0x98, 0xc9,
	0x33, 0x11, 0xaf, 0x0c, 0x08, 0xbe, 0x0f, 0xca, 0x6c, 0x21, 0x40, 0xd2, 0x28, 0x6c, 0xab, 0x96,
	0x6d, 0x14, 0xbd, 0xfb, 0x6c, 0x7d, 0x61, 0xfd, 0x0f, 0x0b, 0x54, 0x1c, 0x86, 0xc7, 0xcc, 0x24,
	0xf0, 0x95, 0x88, 0x71, 0xc0, 0xe0, 0xbb, 0x60, 0x8f, 0x1a, 0x10, 0xad, 0x0f, 0xb9, 0x34, 0x47,
	0x4f, 0x92, 0x51, 0xd7, 0x40, 0x81, 0x88, 0xc9, 0x84, 0xab, 0x09, 0x0b, 0x95, 0xb4, 0xb7, 0xcc,
	0x16, 0xab, 0x10, 0xfc, 0x09, 0xc0, 0x28, 0x2d, 0x6c, 0x51, 0x4b, 0xb6, 0x96, 0x6d, 0x14, 0x8e,
	0x3f, 0x6a, 0xae, 0xb9, 0xa5, 0x79, 0x67, 0x4f, 0x5e, 0x65, 0x25, 0x4f, 0x52, 0x7b, 0x07, 0x3c,
	0xbe, 0x64, 0x31, 0xbf, 0xe2, 0x04, 0x2b, 0x2e, 0xc2, 0x4b, 0x46, 0x94, 0x88, 0xfd, 0xe9, 0x60,
	0xc2, 0xa5, 0xe4, 0x22, 0x84, 0xef, 0x81, 0xfb, 0x49, 0x17, 0xd7, 0x78, 0xcc, 0x29, 0x57, 0x33,
	0x33, 0x85, 0xbc, 0x97, 0x34, 0x77, 0x99, 0xa0, 0xf5, 0xdf, 0xb6, 0x41, 0xd1, 0x8d, 0x04, 0x19,
	0xb6, 0x7b, 0xbe, 0x83, 0x15, 0x86, 0x87, 0x20, 0xcf, 0x74, 0x8c, 0x38, 0x35, 0x9d, 0xe7, 0xbc,
	0x1d, 0x13, 0x77, 0x29, 0xac, 0x83, 0x12, 0x47, 0x4a, 0x28, 0x3c, 0x46, 0xfa, 0x50, 0xa4, 0xb1,
	0x56, 0xc9, 0x2b, 0xf0, 0xa7, 0x1a, 0xf3, 0x35, 0xa4, 0x8f, 0x51, 0xcd, 0x59, 0x44, 0x59, 0x10,
	0x33, 0x66, 0xcc, 0x51, 0xf2, 0x8a, 0xca, 0xf0, 0x8e, 0xc1, 0xe0, 0x39, 0x28, 0xae, 0xf4, 0x24,
	0xed, 0x9c, 0x99, 0xca, 0x5b, 0x1b, 0x53, 0xf9, 0xaf, 0xf7, 0xdb, 0x39, 0x6d, 0x63, 0x6f, 0x6d,
	0x31, 0xfc, 0x0c, 0xec, 0xd2, 0x51, 0x80, 0xa2, 0x21, 0x96, 0xcc, 0x98, 0x66, 0xef, 0xf8, 0x60,
	0x23, 0x93, 0x73, 0xde, 0xe9, 0x6b, 0xda, 0xcb, 0xd3, 0x51, 0x60, 0xbe, 0xe0, 0x97, 0xe0, 0xb1,
	0x1e, 0x05, 0x0f, 0x93, 0x95, 0x88, 0x32, 0x4c, 0xc7, 0x3c, 0x64, 0x68, 0x30, 0x16, 0x64, 0x64,
	0xdf, 0xab, 0x59, 0x8d, 0xac, 0x77, 0x98, 0x68, 0xcc, 0x1a, 0x27, 0x51, 0xb4, 0xb5, 0x00, 0x9e,
	0x82, 0xea, 0xb5, 0x3e, 0x82, 0xd9, 0x6b, 0x53, 0xec, 0x98, 0x14, 0x8f, 0x96, 0xaa, 0xff, 0x49,
	0xd2, 0x00, 0xe5, 0x20, 0x16, 0xd3, 0x68, 0xf5, 0x36, 0xe5, 0xcd, 0x6d, 0xda, 0x33, 0x78, 0x7a,
	0x93, 0x4e, 0x41, 0x31, 0x39, 0x51, 0xdd, 0xbc, 0xb4, 0x77, 0xcd, 0xc8, 0x6a, 0x9b, 0x8d, 0x6e,
	0xfa, 0xd9, 0x2b, 0xd0, 0x25, 0x24, 0xe1, 0x15, 0xb0, 0xaf, 0x57, 0x6c, 0x83, 0xe4, 0xd2, 0x31,
	0xd2, 0x06, 0x26, 0xe1, 0x87, 0x1b, 0x09, 0xef, 0x72, 0x99, 0x77, 0xb0, 0x9a, 0x2c, 0xc5, 0x25,
	0x7c, 0x1b, 0x94, 0x8c, 0xef, 0xd0, 0x7c, 0x73, 0x69, 0x17, 0x8c, 0xf9, 0x8a, 0x06, 0x9c, 0xd7,
	0x28, 0xe1, 0x11, 0xd8, 0x37, 0x71, 0x52, 0x0a, 0x0f, 0x42, 0xac, 0xa6, 0x31, 0xb3, 0x8b, 0xa6,
	0xff, 0x07, 0x29, 0xe7, 0x2f, 0xa8, 0x0f, 0x7e, 0xb5, 0x40, 0x7e, 0x71, 0x96, 0xf0, 0x00, 0x3c,
	0x70, 0xce, 0x3b, 0xa8, 0xff, 0xd5, 0x89, 0xef, 0xa2, 0xef, 0x2e, 0x1c, 0xf7, 0xac, 0x7b, 0xe1,
	0x3a, 0xe5, 0x0c, 0x7c, 0x03, 0x54, 0x52, 0xc2, 0x71, 0x4f, 0x7a, 0xdd, 0x8b, 0x4e, 0xd9, 0x5a,
	0xd7, 0x5f, 0xba, 0x5e, 0xf7, 0xec, 0x07, 0x4d, 0x6c, 0xad, 0x13, 0xa7, 0xdf, 0x7e, 0xd3, 0xef,
	0xb9, 0x4f, 0x5d, 0xa7, 0x9c, 0x85, 0xfb, 0xa0, 0x9c, 0x12, 0x67, 0x27, 0xdd, 0x9e, 0xeb, 0x94,
	0x73, 0xeb, 0xa8, 0xdf, 0xed, 0xe8, 0x4d, 0xb7, 0xdb, 0xdd, 0x17, 0x37, 0x55, 0xeb, 0xe5, 0x4d,
	0xd5, 0xfa, 0xe7, 0xa6, 0x6a, 0x3d, 0xbf, 0xad, 0x66, 0x5e, 0xde, 0x56, 0x33, 0x7f, 0xdd, 0x56,
	0x33, 0x3f, 0xb6, 0x02, 0xae, 0x86, 0xd3, 0x41, 0x93, 0x88, 0x49, 0x2b, 0x8a, 0x05, 0x9d, 0x12,
	0x25, 0x09, 0x37, 0x8f, 0x48, 0xfa, 0x9c, 0x3c, 0x4b, 0x1f, 0x94, 0xc1, 0x3d, 0xf3, 0xf7, 0xff,
	0xe9, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf3, 0xc7, 0xd8, 0xd3, 0x6e, 0x06, 0x00, 0x00,
}

func (m *BLSParticipantInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BLSParticipantInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BLSParticipantInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlotEndIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SlotEndIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.SlotStartIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SlotStartIndex))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Secp256K1PublicKey) > 0 {
		i -= len(m.Secp256K1PublicKey)
		copy(dAtA[i:], m.Secp256K1PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Secp256K1PublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.PercentageWeight.Size()
		i -= size
		if _, err := m.PercentageWeight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptedSharesForParticipant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedSharesForParticipant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptedSharesForParticipant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedShares) > 0 {
		for iNdEx := len(m.EncryptedShares) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedShares[iNdEx])
			copy(dAtA[i:], m.EncryptedShares[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedShares[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DealerPartStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DealerPartStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DealerPartStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParticipantShares) > 0 {
		for iNdEx := len(m.ParticipantShares) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParticipantShares[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Commitments) > 0 {
		for iNdEx := len(m.Commitments) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Commitments[iNdEx])
			copy(dAtA[i:], m.Commitments[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Commitments[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DealerAddress) > 0 {
		i -= len(m.DealerAddress)
		copy(dAtA[i:], m.DealerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DealerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerificationVectorSubmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerificationVectorSubmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerificationVectorSubmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DealerValidity) > 0 {
		for iNdEx := len(m.DealerValidity) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.DealerValidity[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DealerValidity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EpochBLSData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochBLSData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochBLSData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValidationSignature) > 0 {
		i -= len(m.ValidationSignature)
		copy(dAtA[i:], m.ValidationSignature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidationSignature)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ValidDealers) > 0 {
		for iNdEx := len(m.ValidDealers) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.ValidDealers[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidDealers)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.VerificationSubmissions) > 0 {
		for iNdEx := len(m.VerificationSubmissions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VerificationSubmissions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.DealerParts) > 0 {
		for iNdEx := len(m.DealerParts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DealerParts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.GroupPublicKey) > 0 {
		i -= len(m.GroupPublicKey)
		copy(dAtA[i:], m.GroupPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupPublicKey)))
		i--
		dAtA[i] = 0x42
	}
	if m.VerifyingPhaseDeadlineBlock != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VerifyingPhaseDeadlineBlock))
		i--
		dAtA[i] = 0x38
	}
	if m.DealingPhaseDeadlineBlock != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DealingPhaseDeadlineBlock))
		i--
		dAtA[i] = 0x30
	}
	if m.DkgPhase != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DkgPhase))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Participants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TSlotsDegree != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TSlotsDegree))
		i--
		dAtA[i] = 0x18
	}
	if m.ITotalSlots != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ITotalSlots))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BLSParticipantInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.PercentageWeight.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Secp256K1PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SlotStartIndex != 0 {
		n += 1 + sovTypes(uint64(m.SlotStartIndex))
	}
	if m.SlotEndIndex != 0 {
		n += 1 + sovTypes(uint64(m.SlotEndIndex))
	}
	return n
}

func (m *EncryptedSharesForParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptedShares) > 0 {
		for _, b := range m.EncryptedShares {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DealerPartStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DealerAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Commitments) > 0 {
		for _, b := range m.Commitments {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ParticipantShares) > 0 {
		for _, e := range m.ParticipantShares {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VerificationVectorSubmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DealerValidity) > 0 {
		n += 1 + sovTypes(uint64(len(m.DealerValidity))) + len(m.DealerValidity)*1
	}
	return n
}

func (m *EpochBLSData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovTypes(uint64(m.EpochId))
	}
	if m.ITotalSlots != 0 {
		n += 1 + sovTypes(uint64(m.ITotalSlots))
	}
	if m.TSlotsDegree != 0 {
		n += 1 + sovTypes(uint64(m.TSlotsDegree))
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DkgPhase != 0 {
		n += 1 + sovTypes(uint64(m.DkgPhase))
	}
	if m.DealingPhaseDeadlineBlock != 0 {
		n += 1 + sovTypes(uint64(m.DealingPhaseDeadlineBlock))
	}
	if m.VerifyingPhaseDeadlineBlock != 0 {
		n += 1 + sovTypes(uint64(m.VerifyingPhaseDeadlineBlock))
	}
	l = len(m.GroupPublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DealerParts) > 0 {
		for _, e := range m.DealerParts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.VerificationSubmissions) > 0 {
		for _, e := range m.VerificationSubmissions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ValidDealers) > 0 {
		n += 1 + sovTypes(uint64(len(m.ValidDealers))) + len(m.ValidDealers)*1
	}
	l = len(m.ValidationSignature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BLSParticipantInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BLSParticipantInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BLSParticipantInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentageWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PercentageWeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secp256K1PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secp256K1PublicKey = append(m.Secp256K1PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.Secp256K1PublicKey == nil {
				m.Secp256K1PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotStartIndex", wireType)
			}
			m.SlotStartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotStartIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotEndIndex", wireType)
			}
			m.SlotEndIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotEndIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedSharesForParticipant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedSharesForParticipant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedSharesForParticipant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedShares", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedShares = append(m.EncryptedShares, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedShares[len(m.EncryptedShares)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DealerPartStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DealerPartStorage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DealerPartStorage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DealerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitments = append(m.Commitments, make([]byte, postIndex-iNdEx))
			copy(m.Commitments[len(m.Commitments)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantShares", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantShares = append(m.ParticipantShares, &EncryptedSharesForParticipant{})
			if err := m.ParticipantShares[len(m.ParticipantShares)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerificationVectorSubmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerificationVectorSubmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerificationVectorSubmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DealerValidity = append(m.DealerValidity, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.DealerValidity) == 0 {
					m.DealerValidity = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DealerValidity = append(m.DealerValidity, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DealerValidity", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochBLSData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochBLSData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochBLSData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ITotalSlots", wireType)
			}
			m.ITotalSlots = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ITotalSlots |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TSlotsDegree", wireType)
			}
			m.TSlotsDegree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TSlotsDegree |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, BLSParticipantInfo{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DkgPhase", wireType)
			}
			m.DkgPhase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DkgPhase |= DKGPhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealingPhaseDeadlineBlock", wireType)
			}
			m.DealingPhaseDeadlineBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DealingPhaseDeadlineBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyingPhaseDeadlineBlock", wireType)
			}
			m.VerifyingPhaseDeadlineBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifyingPhaseDeadlineBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPublicKey = append(m.GroupPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPublicKey == nil {
				m.GroupPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealerParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DealerParts = append(m.DealerParts, &DealerPartStorage{})
			if err := m.DealerParts[len(m.DealerParts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationSubmissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationSubmissions = append(m.VerificationSubmissions, &VerificationVectorSubmission{})
			if err := m.VerificationSubmissions[len(m.VerificationSubmissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ValidDealers = append(m.ValidDealers, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.ValidDealers) == 0 {
					m.ValidDealers = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ValidDealers = append(m.ValidDealers, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidDealers", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidationSignature = append(m.ValidationSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.ValidationSignature == nil {
				m.ValidationSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
