// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: inference/bls/threshold_signing.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ThresholdSigningStatus defines the different states of a threshold signing request
type ThresholdSigningStatus int32

const (
	// UNDEFINED represents an uninitialized or unknown status
	ThresholdSigningStatus_THRESHOLD_SIGNING_STATUS_UNDEFINED ThresholdSigningStatus = 0
	// PENDING_SIGNING represents the initial state when a signing request is created
	ThresholdSigningStatus_THRESHOLD_SIGNING_STATUS_PENDING_SIGNING ThresholdSigningStatus = 1
	// COLLECTING_SIGNATURES represents the state when collecting partial signatures from participants
	ThresholdSigningStatus_THRESHOLD_SIGNING_STATUS_COLLECTING_SIGNATURES ThresholdSigningStatus = 2
	// COMPLETED represents the state when the threshold signature has been successfully created
	ThresholdSigningStatus_THRESHOLD_SIGNING_STATUS_COMPLETED ThresholdSigningStatus = 3
	// FAILED represents the state when the threshold signing process has failed
	ThresholdSigningStatus_THRESHOLD_SIGNING_STATUS_FAILED ThresholdSigningStatus = 4
	// EXPIRED represents the state when the deadline has passed without sufficient signatures
	ThresholdSigningStatus_THRESHOLD_SIGNING_STATUS_EXPIRED ThresholdSigningStatus = 5
)

var ThresholdSigningStatus_name = map[int32]string{
	0: "THRESHOLD_SIGNING_STATUS_UNDEFINED",
	1: "THRESHOLD_SIGNING_STATUS_PENDING_SIGNING",
	2: "THRESHOLD_SIGNING_STATUS_COLLECTING_SIGNATURES",
	3: "THRESHOLD_SIGNING_STATUS_COMPLETED",
	4: "THRESHOLD_SIGNING_STATUS_FAILED",
	5: "THRESHOLD_SIGNING_STATUS_EXPIRED",
}

var ThresholdSigningStatus_value = map[string]int32{
	"THRESHOLD_SIGNING_STATUS_UNDEFINED":             0,
	"THRESHOLD_SIGNING_STATUS_PENDING_SIGNING":       1,
	"THRESHOLD_SIGNING_STATUS_COLLECTING_SIGNATURES": 2,
	"THRESHOLD_SIGNING_STATUS_COMPLETED":             3,
	"THRESHOLD_SIGNING_STATUS_FAILED":                4,
	"THRESHOLD_SIGNING_STATUS_EXPIRED":               5,
}

func (x ThresholdSigningStatus) String() string {
	return proto.EnumName(ThresholdSigningStatus_name, int32(x))
}

func (ThresholdSigningStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2963c7579e87ce33, []int{0}
}

// SigningData represents the data structure for requesting a threshold signature
// Used as input to the RequestThresholdSignature keeper method
type SigningData struct {
	// current_epoch_id is the epoch to use for signing (must have completed DKG)
	CurrentEpochId uint64 `protobuf:"varint,1,opt,name=current_epoch_id,json=currentEpochId,proto3" json:"current_epoch_id,omitempty"`
	// chain_id is the 32-byte chain identifier for cross-chain security
	ChainId []byte `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// request_id is the unique 32-byte identifier provided by the calling module (e.g., tx_hash)
	RequestId []byte `protobuf:"bytes,3,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// data is the array of 32-byte data chunks to be signed (Ethereum-compatible format)
	Data [][]byte `protobuf:"bytes,4,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *SigningData) Reset()         { *m = SigningData{} }
func (m *SigningData) String() string { return proto.CompactTextString(m) }
func (*SigningData) ProtoMessage()    {}
func (*SigningData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2963c7579e87ce33, []int{0}
}
func (m *SigningData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningData.Merge(m, src)
}
func (m *SigningData) XXX_Size() int {
	return m.Size()
}
func (m *SigningData) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningData.DiscardUnknown(m)
}

var xxx_messageInfo_SigningData proto.InternalMessageInfo

func (m *SigningData) GetCurrentEpochId() uint64 {
	if m != nil {
		return m.CurrentEpochId
	}
	return 0
}

func (m *SigningData) GetChainId() []byte {
	if m != nil {
		return m.ChainId
	}
	return nil
}

func (m *SigningData) GetRequestId() []byte {
	if m != nil {
		return m.RequestId
	}
	return nil
}

func (m *SigningData) GetData() [][]byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ThresholdSigningRequest represents a complete threshold signing request stored on-chain
type ThresholdSigningRequest struct {
	// request_id is the unique 32-byte identifier for this signing request
	RequestId []byte `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// current_epoch_id is the epoch being used for signing
	CurrentEpochId uint64 `protobuf:"varint,2,opt,name=current_epoch_id,json=currentEpochId,proto3" json:"current_epoch_id,omitempty"`
	// chain_id is the 32-byte chain identifier for cross-chain security
	ChainId []byte `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// data is the original array of 32-byte data chunks to be signed
	Data [][]byte `protobuf:"bytes,4,rep,name=data,proto3" json:"data,omitempty"`
	// encoded_data is the Ethereum-compatible abi.encodePacked result
	EncodedData []byte `protobuf:"bytes,5,opt,name=encoded_data,json=encodedData,proto3" json:"encoded_data,omitempty"`
	// message_hash is the keccak256 hash of the encoded_data (32 bytes)
	MessageHash []byte `protobuf:"bytes,6,opt,name=message_hash,json=messageHash,proto3" json:"message_hash,omitempty"`
	// status is the current state of the signing request
	Status ThresholdSigningStatus `protobuf:"varint,7,opt,name=status,proto3,enum=inference.bls.ThresholdSigningStatus" json:"status,omitempty"`
	// partial_signatures contains all partial signatures submitted by participants
	PartialSignatures []PartialSignature `protobuf:"bytes,8,rep,name=partial_signatures,json=partialSignatures,proto3" json:"partial_signatures"`
	// final_signature is the aggregated BLS signature (G1 point, 48-byte compressed format)
	// Only set when status is COMPLETED
	FinalSignature []byte `protobuf:"bytes,9,opt,name=final_signature,json=finalSignature,proto3" json:"final_signature,omitempty"`
	// created_block_height is the block height when this request was created
	CreatedBlockHeight int64 `protobuf:"varint,10,opt,name=created_block_height,json=createdBlockHeight,proto3" json:"created_block_height,omitempty"`
	// deadline_block_height is the block height after which this request expires
	DeadlineBlockHeight int64 `protobuf:"varint,11,opt,name=deadline_block_height,json=deadlineBlockHeight,proto3" json:"deadline_block_height,omitempty"`
}

func (m *ThresholdSigningRequest) Reset()         { *m = ThresholdSigningRequest{} }
func (m *ThresholdSigningRequest) String() string { return proto.CompactTextString(m) }
func (*ThresholdSigningRequest) ProtoMessage()    {}
func (*ThresholdSigningRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2963c7579e87ce33, []int{1}
}
func (m *ThresholdSigningRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdSigningRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdSigningRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdSigningRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdSigningRequest.Merge(m, src)
}
func (m *ThresholdSigningRequest) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdSigningRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdSigningRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdSigningRequest proto.InternalMessageInfo

func (m *ThresholdSigningRequest) GetRequestId() []byte {
	if m != nil {
		return m.RequestId
	}
	return nil
}

func (m *ThresholdSigningRequest) GetCurrentEpochId() uint64 {
	if m != nil {
		return m.CurrentEpochId
	}
	return 0
}

func (m *ThresholdSigningRequest) GetChainId() []byte {
	if m != nil {
		return m.ChainId
	}
	return nil
}

func (m *ThresholdSigningRequest) GetData() [][]byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ThresholdSigningRequest) GetEncodedData() []byte {
	if m != nil {
		return m.EncodedData
	}
	return nil
}

func (m *ThresholdSigningRequest) GetMessageHash() []byte {
	if m != nil {
		return m.MessageHash
	}
	return nil
}

func (m *ThresholdSigningRequest) GetStatus() ThresholdSigningStatus {
	if m != nil {
		return m.Status
	}
	return ThresholdSigningStatus_THRESHOLD_SIGNING_STATUS_UNDEFINED
}

func (m *ThresholdSigningRequest) GetPartialSignatures() []PartialSignature {
	if m != nil {
		return m.PartialSignatures
	}
	return nil
}

func (m *ThresholdSigningRequest) GetFinalSignature() []byte {
	if m != nil {
		return m.FinalSignature
	}
	return nil
}

func (m *ThresholdSigningRequest) GetCreatedBlockHeight() int64 {
	if m != nil {
		return m.CreatedBlockHeight
	}
	return 0
}

func (m *ThresholdSigningRequest) GetDeadlineBlockHeight() int64 {
	if m != nil {
		return m.DeadlineBlockHeight
	}
	return 0
}

func init() {
	proto.RegisterEnum("inference.bls.ThresholdSigningStatus", ThresholdSigningStatus_name, ThresholdSigningStatus_value)
	proto.RegisterType((*SigningData)(nil), "inference.bls.SigningData")
	proto.RegisterType((*ThresholdSigningRequest)(nil), "inference.bls.ThresholdSigningRequest")
}

func init() {
	proto.RegisterFile("inference/bls/threshold_signing.proto", fileDescriptor_2963c7579e87ce33)
}

var fileDescriptor_2963c7579e87ce33 = []byte{
	// 601 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xcf, 0x6f, 0xd3, 0x30,
	0x1c, 0xc5, 0x9b, 0xa6, 0xfb, 0xe5, 0x8e, 0x91, 0x99, 0x01, 0x61, 0x12, 0x5d, 0x18, 0x0c, 0x22,
	0x84, 0x5a, 0x54, 0xce, 0x1c, 0xb6, 0xc5, 0x5b, 0x23, 0x95, 0xae, 0x4a, 0x32, 0x09, 0x71, 0x89,
	0xdc, 0xd8, 0x4b, 0x2c, 0xd2, 0x24, 0xc4, 0x8e, 0x04, 0x7f, 0x00, 0x77, 0x2e, 0xfc, 0x4f, 0x3b,
	0xee, 0xc8, 0x09, 0xa1, 0xed, 0xcf, 0xe0, 0x82, 0xea, 0xa4, 0x63, 0xad, 0x56, 0xb8, 0x54, 0xf6,
	0x7b, 0x9f, 0xf7, 0xed, 0x73, 0x1b, 0x07, 0xec, 0xb1, 0xe4, 0x8c, 0xe6, 0x34, 0x09, 0x68, 0x67,
	0x14, 0xf3, 0x8e, 0x88, 0x72, 0xca, 0xa3, 0x34, 0x26, 0x3e, 0x67, 0x61, 0xc2, 0x92, 0xb0, 0x9d,
	0xe5, 0xa9, 0x48, 0xe1, 0x9d, 0x6b, 0xac, 0x3d, 0x8a, 0xf9, 0xf6, 0x26, 0x1e, 0xb3, 0x24, 0xed,
	0xc8, 0xcf, 0x92, 0xd8, 0xde, 0x0a, 0xd3, 0x30, 0x95, 0xcb, 0xce, 0x64, 0x55, 0xa9, 0xdb, 0xb3,
	0xe3, 0x33, 0x9c, 0xe3, 0x31, 0x2f, 0xbd, 0xdd, 0xaf, 0x0a, 0x68, 0xba, 0xe5, 0xb7, 0x58, 0x58,
	0x60, 0x68, 0x02, 0x2d, 0x28, 0xf2, 0x9c, 0x26, 0xc2, 0xa7, 0x59, 0x1a, 0x44, 0x3e, 0x23, 0xba,
	0x62, 0x28, 0x66, 0xc3, 0xd9, 0xa8, 0x74, 0x34, 0x91, 0x6d, 0x02, 0x1f, 0x81, 0xd5, 0x20, 0xc2,
	0x2c, 0x99, 0x10, 0x75, 0x43, 0x31, 0xd7, 0x9d, 0x15, 0xb9, 0xb7, 0x09, 0x7c, 0x0c, 0x40, 0x4e,
	0x3f, 0x15, 0x94, 0x8b, 0x89, 0xa9, 0x4a, 0x73, 0xad, 0x52, 0x6c, 0x02, 0x21, 0x68, 0x10, 0x2c,
	0xb0, 0xde, 0x30, 0x54, 0x73, 0xdd, 0x91, 0xeb, 0xdd, 0xdf, 0x2a, 0x78, 0xe8, 0x4d, 0xcf, 0x5d,
	0x15, 0x72, 0xca, 0xc4, 0xdc, 0x38, 0x65, 0x7e, 0xdc, 0x6d, 0x95, 0xeb, 0xff, 0xad, 0xac, 0xce,
	0x56, 0xbe, 0xa5, 0x13, 0x7c, 0x02, 0xd6, 0x69, 0x12, 0xa4, 0x84, 0x12, 0x5f, 0x7a, 0x4b, 0x32,
	0xd2, 0xac, 0x34, 0xab, 0x42, 0xc6, 0x94, 0x73, 0x1c, 0x52, 0x3f, 0xc2, 0x3c, 0xd2, 0x97, 0x4b,
	0xa4, 0xd2, 0x7a, 0x98, 0x47, 0xf0, 0x2d, 0x58, 0xe6, 0x02, 0x8b, 0x82, 0xeb, 0x2b, 0x86, 0x62,
	0x6e, 0x74, 0xf7, 0xda, 0x33, 0x7f, 0x63, 0x7b, 0xfe, 0xd4, 0xae, 0x84, 0x9d, 0x2a, 0x04, 0x3d,
	0x00, 0x33, 0x9c, 0x0b, 0x86, 0x63, 0xf9, 0x34, 0x60, 0x51, 0xe4, 0x94, 0xeb, 0xab, 0x86, 0x6a,
	0x36, 0xbb, 0x3b, 0x73, 0xa3, 0x86, 0x25, 0xe8, 0x4e, 0xb9, 0x83, 0xc6, 0xf9, 0xcf, 0x9d, 0x9a,
	0xb3, 0x99, 0xcd, 0xe9, 0x1c, 0xbe, 0x00, 0x77, 0xcf, 0x58, 0x72, 0x73, 0xa6, 0xbe, 0x26, 0xab,
	0x6f, 0x48, 0xf9, 0x9a, 0x84, 0xaf, 0xc1, 0x56, 0x90, 0x53, 0x2c, 0x28, 0xf1, 0x47, 0x71, 0x1a,
	0x7c, 0xf4, 0x23, 0xca, 0xc2, 0x48, 0xe8, 0xc0, 0x50, 0x4c, 0xd5, 0x81, 0x95, 0x77, 0x30, 0xb1,
	0x7a, 0xd2, 0x81, 0x5d, 0x70, 0x9f, 0x50, 0x4c, 0x62, 0x96, 0xd0, 0xd9, 0x48, 0x53, 0x46, 0xee,
	0x4d, 0xcd, 0x1b, 0x99, 0x97, 0xdf, 0xeb, 0xe0, 0xc1, 0xed, 0xbf, 0x03, 0x7c, 0x0e, 0x76, 0xbd,
	0x9e, 0x83, 0xdc, 0xde, 0x49, 0xdf, 0xf2, 0x5d, 0xfb, 0x78, 0x60, 0x0f, 0x8e, 0x7d, 0xd7, 0xdb,
	0xf7, 0x4e, 0x5d, 0xff, 0x74, 0x60, 0xa1, 0x23, 0x7b, 0x80, 0x2c, 0xad, 0x06, 0x5f, 0x01, 0x73,
	0x21, 0x37, 0x44, 0x03, 0x4b, 0x6e, 0x4b, 0x59, 0x53, 0x60, 0x17, 0xb4, 0x17, 0xd2, 0x87, 0x27,
	0xfd, 0x3e, 0x3a, 0xf4, 0xa6, 0x81, 0x7d, 0xef, 0xd4, 0x41, 0xae, 0x56, 0xff, 0x67, 0x93, 0xc3,
	0x93, 0x77, 0xc3, 0x3e, 0xf2, 0x90, 0xa5, 0xa9, 0xf0, 0x29, 0xd8, 0x59, 0xc8, 0x1d, 0xed, 0xdb,
	0x7d, 0x64, 0x69, 0x0d, 0xf8, 0x0c, 0x18, 0x0b, 0x21, 0xf4, 0x7e, 0x68, 0x3b, 0xc8, 0xd2, 0x96,
	0x0e, 0xec, 0xf3, 0xcb, 0x96, 0x72, 0x71, 0xd9, 0x52, 0x7e, 0x5d, 0xb6, 0x94, 0x6f, 0x57, 0xad,
	0xda, 0xc5, 0x55, 0xab, 0xf6, 0xe3, 0xaa, 0x55, 0xfb, 0xd0, 0x09, 0x99, 0x88, 0x8a, 0x51, 0x3b,
	0x48, 0xc7, 0x9d, 0x2c, 0x4f, 0x49, 0x11, 0x08, 0x1e, 0x30, 0x79, 0xc7, 0xff, 0xde, 0xf6, 0xcf,
	0xe5, 0xeb, 0xe4, 0x4b, 0x46, 0xf9, 0x68, 0x59, 0xde, 0xf7, 0x37, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x52, 0x55, 0xac, 0x17, 0x6c, 0x04, 0x00, 0x00,
}

func (m *SigningData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Data[iNdEx])
			copy(dAtA[i:], m.Data[iNdEx])
			i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.Data[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.CurrentEpochId != 0 {
		i = encodeVarintThresholdSigning(dAtA, i, uint64(m.CurrentEpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdSigningRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdSigningRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdSigningRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeadlineBlockHeight != 0 {
		i = encodeVarintThresholdSigning(dAtA, i, uint64(m.DeadlineBlockHeight))
		i--
		dAtA[i] = 0x58
	}
	if m.CreatedBlockHeight != 0 {
		i = encodeVarintThresholdSigning(dAtA, i, uint64(m.CreatedBlockHeight))
		i--
		dAtA[i] = 0x50
	}
	if len(m.FinalSignature) > 0 {
		i -= len(m.FinalSignature)
		copy(dAtA[i:], m.FinalSignature)
		i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.FinalSignature)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PartialSignatures) > 0 {
		for iNdEx := len(m.PartialSignatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartialSignatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintThresholdSigning(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Status != 0 {
		i = encodeVarintThresholdSigning(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.MessageHash) > 0 {
		i -= len(m.MessageHash)
		copy(dAtA[i:], m.MessageHash)
		i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.MessageHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EncodedData) > 0 {
		i -= len(m.EncodedData)
		copy(dAtA[i:], m.EncodedData)
		i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.EncodedData)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Data[iNdEx])
			copy(dAtA[i:], m.Data[iNdEx])
			i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.Data[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CurrentEpochId != 0 {
		i = encodeVarintThresholdSigning(dAtA, i, uint64(m.CurrentEpochId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintThresholdSigning(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintThresholdSigning(dAtA []byte, offset int, v uint64) int {
	offset -= sovThresholdSigning(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SigningData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentEpochId != 0 {
		n += 1 + sovThresholdSigning(uint64(m.CurrentEpochId))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovThresholdSigning(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovThresholdSigning(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, b := range m.Data {
			l = len(b)
			n += 1 + l + sovThresholdSigning(uint64(l))
		}
	}
	return n
}

func (m *ThresholdSigningRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovThresholdSigning(uint64(l))
	}
	if m.CurrentEpochId != 0 {
		n += 1 + sovThresholdSigning(uint64(m.CurrentEpochId))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovThresholdSigning(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, b := range m.Data {
			l = len(b)
			n += 1 + l + sovThresholdSigning(uint64(l))
		}
	}
	l = len(m.EncodedData)
	if l > 0 {
		n += 1 + l + sovThresholdSigning(uint64(l))
	}
	l = len(m.MessageHash)
	if l > 0 {
		n += 1 + l + sovThresholdSigning(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovThresholdSigning(uint64(m.Status))
	}
	if len(m.PartialSignatures) > 0 {
		for _, e := range m.PartialSignatures {
			l = e.Size()
			n += 1 + l + sovThresholdSigning(uint64(l))
		}
	}
	l = len(m.FinalSignature)
	if l > 0 {
		n += 1 + l + sovThresholdSigning(uint64(l))
	}
	if m.CreatedBlockHeight != 0 {
		n += 1 + sovThresholdSigning(uint64(m.CreatedBlockHeight))
	}
	if m.DeadlineBlockHeight != 0 {
		n += 1 + sovThresholdSigning(uint64(m.DeadlineBlockHeight))
	}
	return n
}

func sovThresholdSigning(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozThresholdSigning(x uint64) (n int) {
	return sovThresholdSigning(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SigningData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThresholdSigning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentEpochId", wireType)
			}
			m.CurrentEpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentEpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = append(m.ChainId[:0], dAtA[iNdEx:postIndex]...)
			if m.ChainId == nil {
				m.ChainId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = append(m.RequestId[:0], dAtA[iNdEx:postIndex]...)
			if m.RequestId == nil {
				m.RequestId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, make([]byte, postIndex-iNdEx))
			copy(m.Data[len(m.Data)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThresholdSigning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdSigningRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThresholdSigning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdSigningRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdSigningRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = append(m.RequestId[:0], dAtA[iNdEx:postIndex]...)
			if m.RequestId == nil {
				m.RequestId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentEpochId", wireType)
			}
			m.CurrentEpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentEpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = append(m.ChainId[:0], dAtA[iNdEx:postIndex]...)
			if m.ChainId == nil {
				m.ChainId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, make([]byte, postIndex-iNdEx))
			copy(m.Data[len(m.Data)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedData = append(m.EncodedData[:0], dAtA[iNdEx:postIndex]...)
			if m.EncodedData == nil {
				m.EncodedData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageHash = append(m.MessageHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageHash == nil {
				m.MessageHash = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ThresholdSigningStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialSignatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartialSignatures = append(m.PartialSignatures, PartialSignature{})
			if err := m.PartialSignatures[len(m.PartialSignatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinalSignature = append(m.FinalSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.FinalSignature == nil {
				m.FinalSignature = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBlockHeight", wireType)
			}
			m.CreatedBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadlineBlockHeight", wireType)
			}
			m.DeadlineBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadlineBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipThresholdSigning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThresholdSigning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipThresholdSigning(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowThresholdSigning
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowThresholdSigning
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthThresholdSigning
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupThresholdSigning
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthThresholdSigning
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthThresholdSigning        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowThresholdSigning          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupThresholdSigning = fmt.Errorf("proto: unexpected end of group")
)
